"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateQB = exports.exitWithError = exports.configFileHeader = void 0;
const adapter_node_1 = require("../adapter.node");
const builders_1 = require("./builders");
const index_node_1 = require("../index.node");
const getCasts_1 = require("./queries/getCasts");
const getScalars_1 = require("./queries/getScalars");
const getFunctions_1 = require("./queries/getFunctions");
const getOperators_1 = require("./queries/getOperators");
const introspect = __importStar(require("./queries/getTypes"));
const genutil = __importStar(require("./util/genutil"));
const generateCastMaps_1 = require("./generators/generateCastMaps");
const generateScalars_1 = require("./generators/generateScalars");
const generateObjectTypes_1 = require("./generators/generateObjectTypes");
const generateRuntimeSpec_1 = require("./generators/generateRuntimeSpec");
const generateFunctionTypes_1 = require("./generators/generateFunctionTypes");
const generateOperatorTypes_1 = require("./generators/generateOperatorTypes");
const generateSetImpl_1 = require("./generators/generateSetImpl");
const DEBUG = false;
exports.configFileHeader = `// EdgeDB query builder. To update, run \`npx edgeql-js\``;
function exitWithError(message) {
    console.error(message);
    process.exit(1);
}
exports.exitWithError = exitWithError;
async function generateQB(params) {
    const { outputDir, connectionConfig, target } = params;
    console.log(`Connecting to EdgeDB instance...`);
    let cxn;
    try {
        cxn = (0, index_node_1.createClient)({
            ...connectionConfig,
            concurrency: 5,
        });
    }
    catch (e) {
        return exitWithError(`Failed to connect: ${e.message}`);
    }
    const dir = new builders_1.DirBuilder();
    try {
        console.log(`Introspecting database schema...`);
        const [types, scalars, casts, functions, operators] = await Promise.all([
            introspect.getTypes(cxn, { debug: DEBUG }),
            (0, getScalars_1.getScalars)(cxn),
            (0, getCasts_1.getCasts)(cxn, { debug: DEBUG }),
            (0, getFunctions_1.getFunctions)(cxn),
            (0, getOperators_1.getOperators)(cxn),
        ]);
        const typesByName = {};
        for (const type of types.values()) {
            typesByName[type.name] = type;
            if (!type.name.includes("::"))
                continue;
        }
        const generatorParams = {
            dir,
            types,
            typesByName,
            casts,
            scalars,
            functions,
            operators,
        };
        (0, generateRuntimeSpec_1.generateRuntimeSpec)(generatorParams);
        (0, generateCastMaps_1.generateCastMaps)(generatorParams);
        (0, generateScalars_1.generateScalars)(generatorParams);
        (0, generateObjectTypes_1.generateObjectTypes)(generatorParams);
        (0, generateFunctionTypes_1.generateFunctionTypes)(generatorParams);
        (0, generateOperatorTypes_1.generateOperators)(generatorParams);
        (0, generateSetImpl_1.generateSetImpl)(generatorParams);
        const importsFile = dir.getPath("imports");
        importsFile.addExportStarFrom("edgedb", "edgedb");
        importsFile.addExportFrom({ spec: true }, "./__spec__", true);
        importsFile.addExportStarFrom("syntax", "./syntax/syntax", true);
        importsFile.addExportStarFrom("castMaps", "./castMaps", true);
        const index = dir.getPath("index");
        index.addExportStarFrom(null, "./castMaps", true);
        index.addExportStarFrom(null, "./syntax/syntax", true);
        index.addImport({ $: true }, "edgedb");
        index.addExportFrom({ createClient: true }, "edgedb");
        index.addStarImport("$syntax", "./syntax/syntax", true);
        index.addStarImport("$op", "./operators", true);
        const spreadModules = [
            {
                name: "$op",
                keys: ["op"],
            },
            {
                name: "$syntax",
                keys: [
                    "ASC",
                    "DESC",
                    "EMPTY_FIRST",
                    "EMPTY_LAST",
                    "alias",
                    "array",
                    "cast",
                    "detached",
                    "for",
                    "insert",
                    "is",
                    "literal",
                    "namedTuple",
                    "optional",
                    "select",
                    "set",
                    "tuple",
                    "with",
                    "withParams",
                ],
            },
            {
                name: "_default",
                module: dir.getModule("default"),
            },
            { name: "_std", module: dir.getModule("std") },
        ];
        const excludedKeys = new Set(dir._modules.keys());
        const spreadTypes = [];
        for (let { name, keys, module } of spreadModules) {
            if (module === null || module === void 0 ? void 0 : module.isEmpty()) {
                continue;
            }
            keys = keys !== null && keys !== void 0 ? keys : module.getDefaultExportKeys();
            const conflictingKeys = keys.filter(key => excludedKeys.has(key));
            let typeStr;
            if (conflictingKeys.length) {
                typeStr = `Omit<typeof ${name}, ${conflictingKeys
                    .map(genutil.quote)
                    .join(" | ")}>`;
            }
            else {
                typeStr = `typeof ${name}`;
            }
            spreadTypes.push(name === "$syntax" ? `$.util.OmitDollarPrefixed<${typeStr}>` : typeStr);
            for (const key of keys) {
                excludedKeys.add(key);
            }
        }
        index.nl();
        index.writeln([
            (0, builders_1.dts) `declare `,
            `const ExportDefault`,
            (0, builders_1.t) `: ${spreadTypes.reverse().join(" & \n  ")} & {`,
        ]);
        index.indented(() => {
            for (const [moduleName, internalName] of dir._modules) {
                if (dir.getModule(moduleName).isEmpty())
                    continue;
                index.writeln([
                    (0, builders_1.t) `${genutil.quote(moduleName)}: typeof _${internalName};`,
                ]);
            }
        });
        index.writeln([(0, builders_1.t) `}`, (0, builders_1.r) ` = {`]);
        index.indented(() => {
            for (const { name, module } of [...spreadModules].reverse()) {
                if (module === null || module === void 0 ? void 0 : module.isEmpty()) {
                    continue;
                }
                index.writeln([
                    (0, builders_1.r) `...${name === "$syntax" ? `$.util.omitDollarPrefixed($syntax)` : name},`,
                ]);
            }
            for (const [moduleName, internalName] of dir._modules) {
                if (dir.getModule(moduleName).isEmpty()) {
                    continue;
                }
                index.addDefaultImport(`_${internalName}`, `./modules/${internalName}`, true);
                index.writeln([(0, builders_1.r) `${genutil.quote(moduleName)}: _${internalName},`]);
            }
        });
        index.writeln([(0, builders_1.r) `};`]);
        index.addExport("ExportDefault", undefined, true);
        index.addExportFrom({ Cardinality: true }, "edgedb/dist/reflection");
        index.writeln([
            (0, builders_1.t) `export `,
            (0, builders_1.dts) `declare `,
            (0, builders_1.t) `type Set<
  Type extends $.BaseType,
  Cardinality extends $.Cardinality = $.Cardinality.Many
> = $.TypeSet<Type, Cardinality>;`,
        ]);
    }
    finally {
        await cxn.close();
    }
    await dir.write(outputDir, target === "ts" ? "ts" : "js+dts", target === "cjs" ? "cjs" : "esm");
    const syntaxDir = adapter_node_1.path.join(__dirname, "..", "syntax");
    const syntaxOutDir = adapter_node_1.path.join(outputDir, "syntax");
    if (!(await (0, adapter_node_1.exists)(syntaxOutDir))) {
        await adapter_node_1.fs.mkdir(syntaxOutDir);
    }
    const syntaxFiles = await adapter_node_1.fs.readdir(syntaxDir);
    for (const fileName of syntaxFiles) {
        const filetype = fileName.endsWith(".js")
            ? "js"
            : fileName.endsWith(".mjs")
                ? "esm"
                : fileName.endsWith(".ts")
                    ? fileName.endsWith(".d.ts")
                        ? "dts"
                        : "ts"
                    : null;
        if ((target === "ts" && filetype !== "ts") ||
            (target === "esm" && !(filetype === "esm" || filetype === "dts")) ||
            (target === "cjs" && !(filetype === "js" || filetype === "dts"))) {
            continue;
        }
        const filePath = adapter_node_1.path.join(syntaxDir, fileName);
        let contents = await (0, adapter_node_1.readFileUtf8)(filePath);
        if (filetype === "js") {
            contents = contents
                .replace(/require\("(..\/)?reflection(.*)"\)/g, `require("edgedb/dist/reflection$2")`)
                .replace(/require\("@generated\//g, `require("../`);
        }
        else {
            contents = contents
                .replace(/from "(..\/)?reflection(.*)"/g, `from "edgedb/dist/reflection$2${filetype === "esm" ? ".js" : ""}"`)
                .replace(/from "@generated\//g, `from "../`);
            if (filetype === "esm") {
                contents = contents
                    .replace(/from "edgedb\/dist\/reflection\.js"/g, `from "edgedb/dist/reflection/index.js"`)
                    .replace(/from "(\.?\.\/.+)"/g, `from "$1.mjs"`);
            }
        }
        const outputPath = adapter_node_1.path.join(syntaxOutDir, fileName);
        await adapter_node_1.fs.writeFile(outputPath, contents);
    }
    await adapter_node_1.fs.writeFile(adapter_node_1.path.join(outputDir, "config.json"), `${exports.configFileHeader}\n${JSON.stringify({ target })}\n`);
}
exports.generateQB = generateQB;
