"use strict";
/*!
 * This source file is part of the EdgeDB open source project.
 *
 * Copyright 2020-present MagicStack Inc. and the EdgeDB authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var _a, _b, _c;
Object.defineProperty(exports, "__esModule", { value: true });
exports.createPool = exports.connect = exports.createClient = exports.ClientShell = exports.ClientStats = exports.ClientConnection = exports.ClientInnerConnection = exports.Deferred = exports.HOLDER = void 0;
const errors = __importStar(require("./errors"));
const con_utils_1 = require("./con_utils");
const queues_1 = require("./queues");
const client_1 = require("./client");
const client_2 = require("./client");
const options_1 = require("./options");
const registry_1 = require("./codecs/registry");
const ifaces_1 = require("./ifaces");
const DETACH = Symbol("detach");
const DETACHED = Symbol("detached");
exports.HOLDER = Symbol("holder");
class Deferred {
    constructor() {
        Object.defineProperty(this, "_promise", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_resolve", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_reject", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_result", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_done", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this._done = false;
        this._reject = undefined;
        this._resolve = undefined;
        this._promise = new Promise((resolve, reject) => {
            this._reject = reject;
            this._resolve = (value) => {
                this._done = true;
                this._result = value;
                resolve(value);
            };
        });
    }
    get promise() {
        return this._promise;
    }
    get done() {
        return this._done;
    }
    get result() {
        if (!this._done) {
            throw new Error("The deferred is not resolved.");
        }
        return this._result;
    }
    async setResult(value) {
        while (!this._resolve) {
            await new Promise((resolve) => process.nextTick(resolve));
        }
        this._resolve(value);
    }
    async setFailed(reason) {
        while (!this._reject) {
            await new Promise((resolve) => process.nextTick(resolve));
        }
        this._reject(reason);
    }
}
exports.Deferred = Deferred;
class ClientConnectionHolder {
    constructor(client) {
        Object.defineProperty(this, "_client", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_connection", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_generation", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_inUse", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this._client = client;
        this._connection = null;
        this._inUse = null;
        this._generation = null;
    }
    get connection() {
        return this._connection;
    }
    get client() {
        return this._client;
    }
    terminate() {
        if (this._connection !== null) {
            this._connection.close();
        }
    }
    async connect() {
        if (this._connection !== null) {
            throw new errors.ClientError("ClientConnectionHolder.connect() called while another " +
                "connection already exists");
        }
        this._connection = await this._client.getNewConnection();
        this._connection[ifaces_1.INNER][exports.HOLDER] = this;
        this._generation = this._client.generation;
    }
    async acquire(options) {
        if (this._connection === null || this._connection.isClosed()) {
            this._connection = null;
            await this.connect();
        }
        else if (this._generation !== this._client.generation) {
            this._connection.close();
            this._connection = null;
            await this.connect();
        }
        this._connection[ifaces_1.OPTIONS] = options;
        this._inUse = new Deferred();
        return this._connection;
    }
    async release() {
        var _d;
        if (this._inUse === null) {
            throw new errors.ClientError("ClientConnectionHolder.release() called on " +
                "a free connection holder");
        }
        if (this._generation !== this._client.generation) {
            await ((_d = this._connection) === null || _d === void 0 ? void 0 : _d.close());
            return;
        }
        await this._release();
    }
    async _waitUntilReleased() {
        if (this._inUse === null) {
            return;
        }
        await this._inUse.promise;
    }
    async close() {
        if (this._connection !== null) {
            await this._connection.close();
        }
    }
    async _releaseOnClose() {
        await this._release();
        this._connection = null;
    }
    async _release() {
        var _d, _e;
        if (this._inUse === null) {
            return;
        }
        await ((_e = (_d = this._connection) === null || _d === void 0 ? void 0 : _d[ifaces_1.INNER].connection) === null || _e === void 0 ? void 0 : _e.resetState());
        if (!this._inUse.done) {
            await this._inUse.setResult();
        }
        this._inUse = null;
        this._connection = this._connection[DETACH]();
        this._client.enqueue(this);
    }
}
class ClientInnerConnection extends client_1.InnerConnection {
    constructor(config, registry) {
        super(config, registry);
        Object.defineProperty(this, _a, {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, _b, {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this[DETACHED] = false;
    }
    async reconnect(singleAttempt = false) {
        if (this[DETACHED]) {
            throw new errors.InterfaceError("Connection has been released to a pool");
        }
        return await super.reconnect(singleAttempt);
    }
    detach() {
        const impl = this.connection;
        this.connection = undefined;
        const result = new ClientInnerConnection(this.config, this.registry);
        result.connection = impl;
        return result;
    }
}
exports.ClientInnerConnection = ClientInnerConnection;
_a = DETACHED, _b = exports.HOLDER;
class ClientConnection extends client_2.StandaloneConnection {
    initInner(config, registry) {
        this[ifaces_1.INNER] = new ClientInnerConnection(config, registry);
    }
    cleanup() {
        const holder = this[ifaces_1.INNER][exports.HOLDER];
        if (holder) {
            holder._releaseOnClose();
        }
    }
    [DETACH]() {
        const result = this.shallowClone();
        const inner = this[ifaces_1.INNER];
        const holder = inner[exports.HOLDER];
        const detached = inner[DETACHED];
        inner[exports.HOLDER] = null;
        inner[DETACHED] = true;
        result[ifaces_1.INNER] = inner.detach();
        result[ifaces_1.INNER][exports.HOLDER] = holder;
        result[ifaces_1.INNER][DETACHED] = detached;
        return result;
    }
}
exports.ClientConnection = ClientConnection;
class ClientStats {
    constructor(queueLength, openConnections) {
        Object.defineProperty(this, "_queueLength", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_openConnections", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this._queueLength = queueLength;
        this._openConnections = openConnections;
    }
    get queueLength() {
        return this._queueLength;
    }
    get openConnections() {
        return this._openConnections;
    }
}
exports.ClientStats = ClientStats;
class ClientShell {
    constructor(dsn, connectOptions = {}) {
        Object.defineProperty(this, _c, {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "impl", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "options", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.impl = new ClientImpl(dsn, connectOptions);
        this.options = options_1.Options.defaults();
    }
    shallowClone() {
        const result = Object.create(this.constructor.prototype);
        result.impl = this.impl;
        result.options = this.options;
        return result;
    }
    withTransactionOptions(opt) {
        const result = this.shallowClone();
        result.options = this.options.withTransactionOptions(opt);
        return result;
    }
    withRetryOptions(opt) {
        const result = this.shallowClone();
        result.options = this.options.withRetryOptions(opt);
        return result;
    }
    getStats() {
        console.warn(`The 'Client.getStats()' method is deprecated`);
        return this.impl.getStats();
    }
    async ensureConnected() {
        await this.impl.ensureConnected();
        return this;
    }
    static create(dsn, options) {
        const client = new ClientShell(dsn, options !== null && options !== void 0 ? options : {});
        client.impl.initialize();
        return client;
    }
    async rawTransaction(action) {
        console.warn(`The 'Client.rawTransaction()' method is deprecated, instead try ` +
            `'client.withRetryOptions({attempts: 1}).retryingTransaction()'`);
        const conn = await this.impl.acquire(this.options);
        try {
            return await conn.rawTransaction(action);
        }
        finally {
            await this.impl.release(conn);
        }
    }
    async retryingTransaction(action) {
        console.warn(`The 'Client.retryingTransaction()' method has been renamed ` +
            `to 'Client.transaction()'`);
        return this.transaction(action);
    }
    async transaction(action) {
        const conn = await this.impl.acquire(this.options);
        try {
            return await conn.transaction(action);
        }
        finally {
            await this.impl.release(conn);
        }
    }
    async execute(query) {
        const conn = await this.impl.acquire(this.options);
        try {
            return await conn.execute(query);
        }
        finally {
            await this.impl.release(conn);
        }
    }
    async query(query, args) {
        const conn = await this.impl.acquire(this.options);
        try {
            return await conn.query(query, args);
        }
        finally {
            await this.impl.release(conn);
        }
    }
    async queryJSON(query, args) {
        const conn = await this.impl.acquire(this.options);
        try {
            return await conn.queryJSON(query, args);
        }
        finally {
            await this.impl.release(conn);
        }
    }
    async querySingle(query, args) {
        const conn = await this.impl.acquire(this.options);
        try {
            return await conn.querySingle(query, args);
        }
        finally {
            await this.impl.release(conn);
        }
    }
    async querySingleJSON(query, args) {
        const conn = await this.impl.acquire(this.options);
        try {
            return await conn.querySingleJSON(query, args);
        }
        finally {
            await this.impl.release(conn);
        }
    }
    async queryRequiredSingle(query, args) {
        const conn = await this.impl.acquire(this.options);
        try {
            return await conn.queryRequiredSingle(query, args);
        }
        finally {
            await this.impl.release(conn);
        }
    }
    async queryRequiredSingleJSON(query, args) {
        const conn = await this.impl.acquire(this.options);
        try {
            return await conn.queryRequiredSingleJSON(query, args);
        }
        finally {
            await this.impl.release(conn);
        }
    }
    async close() {
        await this.impl.close();
    }
    isClosed() {
        return this.impl.isClosed();
    }
    terminate() {
        this.impl.terminate();
    }
}
exports.ClientShell = ClientShell;
_c = ifaces_1.ALLOW_MODIFICATIONS;
class ClientImpl {
    constructor(dsn, options = {}) {
        var _d;
        Object.defineProperty(this, "_closed", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_closing", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_queue", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_holders", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_initialized", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_userConcurrency", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_suggestedConcurrency", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_generation", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_connectConfig", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_codecsRegistry", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "__normalizedConnectConfig", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: null
        });
        this.validateClientOptions(options);
        this._codecsRegistry = new registry_1.CodecsRegistry();
        this._queue = new queues_1.LifoQueue();
        this._holders = [];
        this._initialized = false;
        this._userConcurrency = (_d = options.concurrency) !== null && _d !== void 0 ? _d : null;
        this._suggestedConcurrency = null;
        this._closing = false;
        this._closed = false;
        this._generation = 0;
        this._connectConfig = { ...options, ...(dsn !== undefined ? { dsn } : {}) };
    }
    getStats() {
        return new ClientStats(this._queue.pending, this._holders.filter((holder) => holder.connection !== null && holder.connection.isClosed() === false).length);
    }
    async ensureConnected() {
        if (this.getStats().openConnections > 0) {
            return;
        }
        const connHolder = this._holders[0];
        if (!connHolder) {
            throw new Error("Client pool is empty");
        }
        await connHolder.connect();
    }
    get generation() {
        return this._generation;
    }
    enqueue(holder) {
        this._queue.push(holder);
    }
    validateClientOptions(opts) {
        if (opts.concurrency != null &&
            (typeof opts.concurrency !== "number" ||
                !Number.isInteger(opts.concurrency) ||
                opts.concurrency < 0)) {
            throw new Error(`invalid 'concurrency' value: ` +
                `expected integer greater than 0 (got ${JSON.stringify(opts.concurrency)})`);
        }
    }
    get _concurrency() {
        var _d, _e;
        return (_e = (_d = this._userConcurrency) !== null && _d !== void 0 ? _d : this._suggestedConcurrency) !== null && _e !== void 0 ? _e : 1;
    }
    initialize() {
        if (this._initialized) {
            return;
        }
        if (this._closed) {
            throw new errors.InterfaceError("The client is closed");
        }
        this._resizeHolderPool();
        this._initialized = true;
    }
    _resizeHolderPool() {
        const holdersDiff = this._concurrency - this._holders.length;
        if (holdersDiff > 0) {
            for (let i = 0; i < holdersDiff; i++) {
                const connectionHolder = new ClientConnectionHolder(this);
                this._holders.push(connectionHolder);
                this._queue.push(connectionHolder);
            }
        }
        else if (holdersDiff < 0) {
        }
    }
    get _normalizedConnectConfig() {
        var _d;
        return ((_d = this.__normalizedConnectConfig) !== null && _d !== void 0 ? _d : (this.__normalizedConnectConfig = (0, con_utils_1.parseConnectArguments)(this._connectConfig)));
    }
    async getNewConnection() {
        var _d;
        const connection = await ClientConnection.connect(await this._normalizedConnectConfig, this._codecsRegistry);
        const suggestedConcurrency = (_d = connection[ifaces_1.INNER].connection) === null || _d === void 0 ? void 0 : _d.serverSettings.suggested_pool_concurrency;
        if (suggestedConcurrency) {
            this._suggestedConcurrency = suggestedConcurrency;
            this._resizeHolderPool();
        }
        return connection;
    }
    _checkInit() {
        if (!this._initialized) {
            throw new errors.InterfaceError("The client is not initialized. Call the ``initialize`` method " +
                "before using it.");
        }
        if (this._closed) {
            throw new errors.InterfaceError("The client is closed");
        }
    }
    async acquire(options) {
        if (this._closing) {
            throw new errors.InterfaceError("The client is closing");
        }
        if (this._closed) {
            throw new errors.InterfaceError("The client is closed");
        }
        this._checkInit();
        return await this._acquireConnection(options);
    }
    async _acquireConnection(options) {
        const connectionHolder = await this._queue.get();
        try {
            return await connectionHolder.acquire(options);
        }
        catch (error) {
            this._queue.push(connectionHolder);
            throw error;
        }
    }
    async release(connection) {
        if (!(connection instanceof ClientConnection)) {
            throw new Error("a connection obtained via client.acquire() was expected");
        }
        const holder = connection[ifaces_1.INNER][exports.HOLDER];
        if (holder == null) {
            return;
        }
        if (holder.client !== this) {
            throw new errors.InterfaceError("The connection proxy does not belong to this client.");
        }
        this._checkInit();
        return await holder.release();
    }
    async close() {
        if (this._closed) {
            return;
        }
        this._checkInit();
        this._closing = true;
        const warningTimeoutId = setTimeout(() => {
            this._warn_on_long_close();
        }, 60e3);
        try {
            await Promise.all(this._holders.map((connectionHolder) => connectionHolder._waitUntilReleased()));
            await Promise.all(this._holders.map((connectionHolder) => connectionHolder.close()));
        }
        catch (error) {
            this.terminate();
            throw error;
        }
        finally {
            clearTimeout(warningTimeoutId);
            this._closed = true;
            this._closing = false;
        }
    }
    isClosed() {
        return this._closed;
    }
    terminate() {
        if (this._closed) {
            return;
        }
        this._checkInit();
        for (const connectionHolder of this._holders) {
            connectionHolder.terminate();
        }
        this._closed = true;
    }
    _warn_on_long_close() {
        console.warn("Client.close() is taking over 60 seconds to complete. " +
            "Check if you have any unreleased connections left.");
    }
}
function _createClientWithLegacyArgs(dsnOrInstanceName, options) {
    if (typeof dsnOrInstanceName === "string") {
        return ClientShell.create(dsnOrInstanceName, options);
    }
    else {
        if (dsnOrInstanceName != null) {
            console.warn("`options` as the first argument to `edgedb.createClient` is " +
                "deprecated, use " +
                "`edgedb.createClient(dsnOrInstanceName, options)`");
        }
        const opts = { ...dsnOrInstanceName, ...options };
        return ClientShell.create(undefined, opts);
    }
}
function createClient(options) {
    if (typeof options === "string") {
        return ClientShell.create(options);
    }
    else {
        return ClientShell.create(undefined, options);
    }
}
exports.createClient = createClient;
function connect(dsnOrInstanceName, options) {
    console.warn(`The 'connect()' API is deprecated, use 'createClient()' instead`);
    return _createClientWithLegacyArgs(dsnOrInstanceName, {
        concurrency: 1,
        ...options,
    }).ensureConnected();
}
exports.connect = connect;
function createPool(dsnOrInstanceName, options) {
    console.warn(`The 'createPool()' API is deprecated, use 'createClient()' instead`);
    const [dsn, opts] = typeof dsnOrInstanceName === "string"
        ? [dsnOrInstanceName, options]
        : [undefined, { ...dsnOrInstanceName, ...options }];
    return _createClientWithLegacyArgs(dsn, {
        ...opts === null || opts === void 0 ? void 0 : opts.connectOptions,
        concurrency: opts === null || opts === void 0 ? void 0 : opts.maxSize,
    }).ensureConnected();
}
exports.createPool = createPool;
