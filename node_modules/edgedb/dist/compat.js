"use strict";
/*!
 * This source file is part of the EdgeDB open source project.
 *
 * Copyright 2019-present MagicStack Inc. and the EdgeDB authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.decodeMicrosecondsToEdgeDBDateTime = exports.decodeInt64ToString = exports.inspect = void 0;
const bi = __importStar(require("./primitives/bigint"));
const dateutil_1 = require("./datatypes/dateutil");
let inspect = (() => {
    const f = () => null;
    f.custom = Symbol();
    return f;
})();
exports.inspect = inspect;
if (typeof window === "undefined" && typeof Deno === "undefined") {
    const utilMod = require("util");
    exports.inspect = inspect = utilMod.inspect;
}
function decodeInt64ToString(buf) {
    if (buf.length !== 8) {
        throw new Error("expected 8 bytes buffer");
    }
    let inp = Array.from(buf);
    let negative = false;
    if (inp[0] & 0x80) {
        inp = inp.map((x) => x ^ 0xff);
        inp[inp.length - 1]++;
        negative = true;
    }
    let result = "0";
    for (const digit of inp) {
        let acc = digit;
        let ret = "";
        for (let j = result.length - 1; j >= 0; j--) {
            const num = parseInt(result[j], 10) * 256 + acc;
            ret = (num % 10) + ret;
            acc = Math.floor(num / 10);
        }
        result = acc ? acc + ret : ret;
    }
    return negative ? `-${result}` : result;
}
exports.decodeInt64ToString = decodeInt64ToString;
const DATESHIFT_ORD = (0, dateutil_1.ymd2ord)(2000, 1, 1);
function decodeMicrosecondsToEdgeDBDateTime(microseconds) {
    const bigUsPerDay = bi.make(86400000000);
    const dayNumber = bi.div(microseconds, bigUsPerDay);
    let timeUs = Number(bi.sub(microseconds, bi.mul(dayNumber, bigUsPerDay)));
    let ord = Number(dayNumber) + DATESHIFT_ORD;
    if (timeUs < 0) {
        timeUs = 86400000000 + timeUs;
        ord -= 1;
    }
    const [_year, month, day] = (0, dateutil_1.ord2ymd)(ord);
    const year = _year <= 0 ? _year - 1 : _year;
    const hour = Math.floor(timeUs / 3600000000);
    timeUs -= hour * 3600000000;
    const minute = Math.floor(timeUs / 60000000);
    timeUs -= minute * 60000000;
    const second = Math.floor(timeUs / 1000000);
    timeUs -= second * 1000000;
    return {
        year,
        month,
        day,
        hour,
        minute,
        second,
        microsecond: timeUs,
    };
}
exports.decodeMicrosecondsToEdgeDBDateTime = decodeMicrosecondsToEdgeDBDateTime;
