import { cardinalityUtil, ExpressionKind, TypeKind, Cardinality, } from "../reflection";
import { $arrayLikeIndexify, $tuplePathify } from "./collections";
import { literalToTypeSet } from "@generated/castMaps";
import { $toEdgeQL } from "./toEdgeQL";
import { $queryFunc } from "./query";
function PathLeaf(root, parent, exclusive, scopeRoot = null) {
    return $expressionify({
        __kind__: ExpressionKind.PathLeaf,
        __element__: root.__element__,
        __cardinality__: root.__cardinality__,
        __parent__: parent,
        __exclusive__: exclusive,
        __scopeRoot__: scopeRoot,
    });
}
function PathNode(root, parent, exclusive, scopeRoot = null) {
    return $expressionify({
        __kind__: ExpressionKind.PathNode,
        __element__: root.__element__,
        __cardinality__: root.__cardinality__,
        __parent__: parent,
        __exclusive__: exclusive,
        __scopeRoot__: scopeRoot,
    });
}
const _pathCache = Symbol();
const _pointers = Symbol();
const pathifyProxyHandlers = {
    get(target, prop, proxy) {
        var _a, _b, _c;
        const ptr = target[_pointers][prop];
        if (ptr) {
            return ((_a = target[_pathCache][prop]) !== null && _a !== void 0 ? _a : (target[_pathCache][prop] = (ptr.__kind__ === "property" ? PathLeaf : PathNode)({
                __element__: ptr.target,
                __cardinality__: cardinalityUtil.multiplyCardinalities(target.__cardinality__, ptr.cardinality),
            }, {
                linkName: prop,
                type: proxy,
            }, (_b = ptr.exclusive) !== null && _b !== void 0 ? _b : false, (_c = target.__scopeRoot__) !== null && _c !== void 0 ? _c : (scopeRoots.has(proxy) ? proxy : null))));
        }
        return target[prop];
    },
};
function _$pathify(_root) {
    var _a;
    if (_root.__element__.__kind__ !== TypeKind.object) {
        return _root;
    }
    const root = _root;
    let pointers = {
        ...root.__element__.__pointers__,
    };
    if (root.__parent__) {
        const { type, linkName } = root.__parent__;
        const parentPointer = type.__element__.__pointers__[linkName];
        if ((parentPointer === null || parentPointer === void 0 ? void 0 : parentPointer.__kind__) === "link") {
            pointers = { ...pointers, ...parentPointer.properties };
        }
    }
    for (const [key, val] of Object.entries(root.__element__.__shape__ || { id: true })) {
        if (((_a = val) === null || _a === void 0 ? void 0 : _a.__element__) && !pointers[key]) {
            pointers[key] = {
                __kind__: "property",
                target: val.__element__,
                cardinality: val.__cardinality__,
                exclusive: false,
                computed: true,
                readonly: true,
                hasDefault: false,
            };
        }
    }
    root[_pointers] = pointers;
    root[_pathCache] = {};
    return new Proxy(root, pathifyProxyHandlers);
}
function isFunc(expr) {
    return $expressionify({
        __kind__: ExpressionKind.TypeIntersection,
        __cardinality__: this.__cardinality__,
        __element__: {
            ...expr.__element__,
            __shape__: { id: true },
        },
        __expr__: this,
    });
}
function assert_single(expr) {
    return $expressionify({
        __kind__: ExpressionKind.Function,
        __element__: expr.__element__,
        __cardinality__: cardinalityUtil.overrideUpperBound(expr.__cardinality__, "One"),
        __name__: "std::assert_single",
        __args__: [expr],
        __namedargs__: {},
    });
}
const jsonDestructureProxyHandlers = {
    get(target, prop, proxy) {
        if (typeof prop === "string" &&
            prop !== "run" &&
            target[prop] === undefined) {
            const parsedProp = Number.isInteger(Number(prop)) ? Number(prop) : prop;
            return jsonDestructure.call(proxy, parsedProp);
        }
        return target[prop];
    },
};
function jsonDestructure(path) {
    const pathTypeSet = literalToTypeSet(path);
    return $expressionify({
        __kind__: ExpressionKind.Operator,
        __element__: this.__element__,
        __cardinality__: cardinalityUtil.multiplyCardinalities(this.__cardinality__, pathTypeSet.__cardinality__),
        __name__: "[]",
        __opkind__: "Infix",
        __args__: [this, pathTypeSet],
    });
}
export function $jsonDestructure(_expr) {
    if (_expr.__element__.__kind__ === TypeKind.scalar &&
        _expr.__element__.__name__ === "std::json") {
        const expr = new Proxy(_expr, jsonDestructureProxyHandlers);
        expr.destructure = jsonDestructure.bind(expr);
        return expr;
    }
    return _expr;
}
export function $expressionify(_expr) {
    const expr = _$pathify($jsonDestructure($arrayLikeIndexify($tuplePathify(_expr))));
    expr.run = $queryFunc.bind(expr);
    expr.is = isFunc.bind(expr);
    expr.toEdgeQL = $toEdgeQL.bind(expr);
    expr.assert_single = () => assert_single(expr);
    return Object.freeze(expr);
}
const scopedExprCache = new WeakMap();
const scopeRoots = new WeakSet();
export function $getScopedExpr(expr, existingScopes) {
    let scopedExpr = scopedExprCache.get(expr);
    if (!scopedExpr || (existingScopes === null || existingScopes === void 0 ? void 0 : existingScopes.has(scopedExpr))) {
        const uncached = !scopedExpr;
        scopedExpr = $expressionify({
            ...expr,
            __cardinality__: Cardinality.One,
            __scopedFrom__: expr,
        });
        scopeRoots.add(scopedExpr);
        if (uncached) {
            scopedExprCache.set(expr, scopedExpr);
        }
    }
    existingScopes === null || existingScopes === void 0 ? void 0 : existingScopes.add(scopedExpr);
    return scopedExpr;
}
export { _$pathify as $pathify, PathLeaf as $PathLeaf, PathNode as $PathNode };
